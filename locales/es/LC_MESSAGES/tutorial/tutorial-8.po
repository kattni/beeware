#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-31 17:25-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.15.6\n"

#: docs/tutorial/tutorial-8.md:1
msgid "Tutorial 8 - Making it Smooooth"
msgstr ""

#: docs/tutorial/tutorial-8.md:3
msgid ""
"So far, our application has been relatively simple - displaying GUI widgets, "
"calling a simple third-party library, and displaying output in a dialog. All "
"these operations happen very quickly, and our application remains responsive."
msgstr ""

#: docs/tutorial/tutorial-8.md:8
msgid ""
"However, in a real world application, we\\'ll need to perform complex tasks "
"or calculations that may take a while to complete - and as those tasks are "
"performed, we want our application to remain responsive. Let\\'s make a "
"change to our application that might take a little time to complete, and see "
"the changes that need to be made to accommodate that behavior."
msgstr ""

#: docs/tutorial/tutorial-8.md:15
msgid "Accessing an API"
msgstr ""

#: docs/tutorial/tutorial-8.md:17
msgid ""
"A common time-consuming task an app will need to perform is to make a "
"request on a web API to retrieve data, and display that data to the user. "
"Web APIs sometimes take a second or two to respond, so if we\\'re calling an "
"API like that, we need to ensure our application doesn\\'t become "
"unresponsive while we wait for the web API to return an answer."
msgstr ""

#: docs/tutorial/tutorial-8.md:23
msgid ""
"This is a toy app, so we don\\'t have a *real* API to work with, so we\\'ll "
"use the [{JSON} Placeholder API]{1} as a source of data. The {JSON} "
"Placeholder API has a number of \\\"fake\\\" API endpoints you can use as "
"test data. One of those APIs is the `/posts/` endpoint, which returns fake "
"blog posts. If you open `https://jsonplaceholder.typicode.com/posts/42` in "
"your browser, you\\'ll get a JSON payload describing a single post - some "
"[Lorum ipsum]{2} content for a blog post with ID 42."
msgstr ""

#: docs/tutorial/tutorial-8.md:34
msgid ""
"The Python standard library contains all the tools you\\'d need to access an "
"API. However, the built-in APIs are very low level. They are good "
"implementations of the HTTP protocol - but they require the user to manage "
"lots of low-level details, like URL redirection, sessions, authentication, "
"and payload encoding. As a \\\"normal browser user\\\" you\\'re probably "
"used to taking these details for granted, as a browser manages them for you."
msgstr ""

#: docs/tutorial/tutorial-8.md:42
msgid ""
"As a result, people have developed third-party libraries that wrap the built-"
"in APIs and provide a simpler API that is a closer match for the everyday "
"browser experience. We\\'re going to use one of those libraries to access "
"the {JSON} Placeholder API - a library called [httpx]{1}. Briefcase uses "
"`httpx` internally, so it\\'s already in your local environment -you don\\'t "
"need to install it separately to use it here."
msgstr ""

#: docs/tutorial/tutorial-8.md:50
msgid ""
"Let\\'s add a `httpx` API call to our app. Modify the `requires` setting in "
"our `pyproject.toml` to include the new requirement:"
msgstr ""

#: docs/tutorial/tutorial-8.md:58
msgid "Add an import to the top of the `app.py` to import `httpx`:"
msgstr ""

#: docs/tutorial/tutorial-8.md:62
msgid "Then modify the `say_hello()` callback so it looks like this:"
msgstr ""

#: docs/tutorial/tutorial-8.md:78
msgid ""
"This will change the `say_hello()` callback so that when it is invoked, it "
"will:"
msgstr ""

#: docs/tutorial/tutorial-8.md:81
msgid "make a GET request on the JSON placeholder API to obtain post 42;"
msgstr ""

#: docs/tutorial/tutorial-8.md:82
msgid "decode the response as JSON;"
msgstr ""

#: docs/tutorial/tutorial-8.md:83
msgid "extract the body of the post; and"
msgstr ""

#: docs/tutorial/tutorial-8.md:84
msgid ""
"include the body of that post as the text of the \\\"message\\\" dialog, in "
"place of the text generated by Faker."
msgstr ""

#: docs/tutorial/tutorial-8.md:87
msgid ""
"Lets run our updated app in Briefcase developer mode to check that our "
"change has worked. As we\\'ve added a new requirement, we need to tell "
"developer mode to reinstall requirements, by using the `-r` argument:"
msgstr ""

#: docs/tutorial/tutorial-8.md:91
msgctxt "docs/tutorial/tutorial-8.md:91"
msgid ":::::::: {.tabs} ::: {.group-tab} macOS"
msgstr ""

#: docs/tutorial/tutorial-8.md:104
msgctxt "docs/tutorial/tutorial-8.md:104"
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr ""

#: docs/tutorial/tutorial-8.md:107
msgid "![Hello World Tutorial 8 dialog, on macOS]{1}{.align-center} :::"
msgstr ""

#: docs/tutorial/tutorial-8.md:110
msgctxt "docs/tutorial/tutorial-8.md:110"
msgid "::: {.group-tab} Linux"
msgstr ""

#: docs/tutorial/tutorial-8.md:122
msgctxt "docs/tutorial/tutorial-8.md:122"
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr ""

#: docs/tutorial/tutorial-8.md:125
msgid "![Hello World Tutorial 8 dialog, on Linux]{1}{.align-center} :::"
msgstr ""

#: docs/tutorial/tutorial-8.md:128
msgctxt "docs/tutorial/tutorial-8.md:128"
msgid "::: {.group-tab} Windows"
msgstr ""

#: docs/tutorial/tutorial-8.md:140
msgctxt "docs/tutorial/tutorial-8.md:140"
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr ""

#: docs/tutorial/tutorial-8.md:143
msgid "![Hello World Tutorial 8 dialog, on Windows]{1}{.align-center} :::"
msgstr ""

#: docs/tutorial/tutorial-8.md:146
msgctxt "docs/tutorial/tutorial-8.md:146"
msgid "::: {.group-tab} Android"
msgstr ""

#: docs/tutorial/tutorial-8.md:149
msgid ""
"You can\\'t run an Android app in developer mode - use the instructions for "
"your chosen desktop platform. :::"
msgstr ""

#: docs/tutorial/tutorial-8.md:153
msgctxt "docs/tutorial/tutorial-8.md:153"
msgid "::: {.group-tab} iOS"
msgstr ""

#: docs/tutorial/tutorial-8.md:156
msgid ""
"You can\\'t run an iOS app in developer mode - use the instructions for your "
"chosen desktop platform. ::: ::::::::"
msgstr ""

#: docs/tutorial/tutorial-8.md:161
msgid ""
"Unless you\\'ve got a *really* fast internet connection, you may notice that "
"when you press the button, the GUI for your app locks up for a little bit. "
"The operating system may even manifest this with a \\\"beachball\\\" or \\"
"\"spinner\\\" cursor to indicate that the app is being unresponsive."
msgstr ""

#: docs/tutorial/tutorial-8.md:167
msgid ""
"This is because the web request we have made is *synchronous*. When our "
"application makes the web request, it waits for the API to return a response "
"before continuing. While it\\'s waiting, it *isn\\'t* allowing the "
"application to redraw - and as a result, the application locks up."
msgstr ""

#: docs/tutorial/tutorial-8.md:172
msgid "GUI Event Loops"
msgstr ""

#: docs/tutorial/tutorial-8.md:174
msgid ""
"To understand why this happens, we need to dig into the details of how a GUI "
"application works. The specifics vary depending on the platform; but the "
"high level concepts are the same, no matter the platform or GUI environment "
"you\\'re using."
msgstr ""

#: docs/tutorial/tutorial-8.md:179
msgid "A GUI app is, fundamentally, a single loop that looks something like:"
msgstr ""

#: docs/tutorial/tutorial-8.md:185
msgid ""
"This loop is called the *Event Loop*. (These aren\\'t actual method names - "
"it\\'s an illustration of what is going on using \\\"pseudo-code\\\")."
msgstr ""

#: docs/tutorial/tutorial-8.md:189
msgid ""
"When you click on a button, or drag a scroll bar, or type a key, you are "
"generating an \\\"event\\\". That \\\"event\\\" is put onto a queue, and the "
"app will process the queue of events when it next has the opportunity to do "
"so. The user code that is triggered in response to the event is called an *"
"event handler*. These event handlers are invoked as part of the "
"`process_events()` call."
msgstr ""

#: docs/tutorial/tutorial-8.md:196
msgid ""
"Once an app has processed all the available events, it will `redraw()` the "
"GUI. This takes into account any changes that the events have caused to the "
"display of the app, as well as anything else that is going on in the "
"operating system - for example, the windows of another app may obscure or "
"reveal part of our app\\'s window, and our app\\'s redraw will need to "
"reflect the portion of the window that is currently visible."
msgstr ""

#: docs/tutorial/tutorial-8.md:203
msgid ""
"The important detail to notice: while an application is processing an event, "
"*it can\\'t redraw*, and *it can\\'t process other events*."
msgstr ""

#: docs/tutorial/tutorial-8.md:206
msgid ""
"This means any user logic contained in an event handler needs to complete "
"quickly. Any delay in completing the event handler will be observed by the "
"user as a slowdown (or stop) in GUI updates. If this delay is long enough, "
"your operating system may report this as a problem - the macOS \\"
"\"beachball\\\" and Windows \\\"spinner\\\" icons are the operating system "
"telling you that your app is taking too long in an event handler."
msgstr ""

#: docs/tutorial/tutorial-8.md:214
msgid ""
"Simple operations like \\\"update a label\\\", or \\"
"\"recompute the total of the inputs\\\" are easy to complete quickly. "
"However, there are a lot of operations that can\\'t be completed quickly. If "
"you\\'re performing a complex mathematical calculation, or indexing all the "
"files on a file system, or performing a large network request, you can\\'t \\"
"\"just do it quickly\\\" - the operations are inherently slow."
msgstr ""

#: docs/tutorial/tutorial-8.md:221
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr ""

#: docs/tutorial/tutorial-8.md:223
msgid "Asynchronous programming"
msgstr ""

#: docs/tutorial/tutorial-8.md:225
msgid ""
"What we need is a way to tell an app in the middle of a long-lived event "
"handler that it is OK to temporarily release control back to the event loop, "
"as long as we can resume where we left off. It\\'s up to the app to "
"determine when this release can occur; but if the app releases control to "
"the event loop regularly, we can have a long-running event handler *and* "
"maintain a responsive UI."
msgstr ""

#: docs/tutorial/tutorial-8.md:232
msgid ""
"We can do this by using *asynchronous programming*. Asynchronous programming "
"is a way to describe a program that allows the interpreter to run multiple "
"functions at the same time, sharing resources between all the concurrently "
"running functions."
msgstr ""

#: docs/tutorial/tutorial-8.md:237
msgid ""
"Asynchronous functions (known as *coroutines*) need to be explicitly "
"declared as being asynchronous. They also need to internally declare when an "
"opportunity exists to change context to another coroutine."
msgstr ""

#: docs/tutorial/tutorial-8.md:241
msgid ""
"In Python, asynchronous programming is implemented using the `async` and "
"`await` keywords, and the [asyncio]{1} module in the standard library. The "
"`async` keyword allows us to declare that a function is an asynchronous "
"coroutine. The `await` keyword provides a way to declare when an opportunity "
"exists to change context to another coroutine. The [asyncio]{2} module "
"provides some other useful tools and primitives for asynchronous coding."
msgstr ""

#: docs/tutorial/tutorial-8.md:251
msgid "Making the tutorial asynchronous"
msgstr ""

#: docs/tutorial/tutorial-8.md:253
msgid ""
"To make our tutorial asynchronous, modify the `say_hello()` event handler so "
"it looks like this:"
msgstr ""

#: docs/tutorial/tutorial-8.md:270
msgid ""
"There are only three changes to this callback from the previous version:"
msgstr ""

#: docs/tutorial/tutorial-8.md:272
msgid ""
"The client that is created is an asynchronous `AsyncClient()`, rather than a "
"synchronous `Client()`. This tells `httpx` that it should operate in "
"asynchronous mode, rather than synchronous mode."
msgstr ""

#: docs/tutorial/tutorial-8.md:275
msgid ""
"The context manager used to create the client is marked as `async`. This "
"tells Python that there is an opportunity to release control as the context "
"manager is entered and exited."
msgstr ""

#: docs/tutorial/tutorial-8.md:278
msgid ""
"The `get` call is made with an `await` keyword. This instructs the app that "
"while we are waiting for the response from the network, the app can release "
"control to the event loop. We\\'ve seen this keyword before - we also use "
"`await` when displaying the dialog box. The reason for that usage is the "
"same as it is for the HTTP request - we need to tell the app that while the "
"dialog is displayed, and we\\'re waiting for the user to push a button, it\\"
"'s OK to release control back to the event loop."
msgstr ""

#: docs/tutorial/tutorial-8.md:287
msgid ""
"It\\'s also important to note that the handler itself is defined as `async "
"def`, rather than just `def`. This tells Python that the method is an "
"asynchronous coroutine. We made this change back in Tutorial 3 when we added "
"the dialog box. You can only use `await` statements inside a method that is "
"declared as `async def`."
msgstr ""

#: docs/tutorial/tutorial-8.md:293
msgid ""
"Toga allows you to use regular methods or asynchronous coroutines as "
"handlers; Toga manages everything behind the scenes to make sure the handler "
"is invoked or awaited as required."
msgstr ""

#: docs/tutorial/tutorial-8.md:297
msgid ""
"If you save these changes and re-run the app in development mode, there won\\"
"'t be any obvious changes to the app. However, when you click on the button "
"to trigger the dialog, you may notice a number of subtle improvements:"
msgstr ""

#: docs/tutorial/tutorial-8.md:302
msgid ""
"The button returns to an \\\"unclicked\\\" state, rather than being stuck in "
"a \\\"clicked\\\" state."
msgstr ""

#: docs/tutorial/tutorial-8.md:304
msgid "The \\\"beachball\\\"/\\\"spinner\\\" icon won\\'t appear"
msgstr ""

#: docs/tutorial/tutorial-8.md:305
msgid ""
"If you move/resize the app window while waiting for the dialog to appear, "
"the window will redraw."
msgstr ""

#: docs/tutorial/tutorial-8.md:307
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr ""

#: docs/tutorial/tutorial-8.md:309
msgid ""
"We can now run the full app. However, as we\\'ve added an extra requirement "
"(`httpx`) we also need to update our app\\'s requirements; we can do this by "
"passing `-r` to `briefcase run`. This will update our app\\'s requirements, "
"then re-build the app, then launch the app:"
msgstr ""

#: docs/tutorial/tutorial-8.md:314
msgctxt "docs/tutorial/tutorial-8.md:314"
msgid ":::::::: {.tabs} ::: {.group-tab} macOS"
msgstr ""

#: docs/tutorial/tutorial-8.md:321
msgctxt "docs/tutorial/tutorial-8.md:321"
msgid ":::"
msgstr ""

#: docs/tutorial/tutorial-8.md:323
msgctxt "docs/tutorial/tutorial-8.md:323"
msgid "::: {.group-tab} Linux"
msgstr ""

#: docs/tutorial/tutorial-8.md:329
msgctxt "docs/tutorial/tutorial-8.md:329"
msgid ":::"
msgstr ""

#: docs/tutorial/tutorial-8.md:331
msgctxt "docs/tutorial/tutorial-8.md:331"
msgid "::: {.group-tab} Windows"
msgstr ""

#: docs/tutorial/tutorial-8.md:337
msgctxt "docs/tutorial/tutorial-8.md:337"
msgid ":::"
msgstr ""

#: docs/tutorial/tutorial-8.md:339
msgctxt "docs/tutorial/tutorial-8.md:339"
msgid "::: {.group-tab} Android"
msgstr ""

#: docs/tutorial/tutorial-8.md:345
msgctxt "docs/tutorial/tutorial-8.md:345"
msgid ":::"
msgstr ""

#: docs/tutorial/tutorial-8.md:347
msgctxt "docs/tutorial/tutorial-8.md:347"
msgid "::: {.group-tab} iOS"
msgstr ""

#: docs/tutorial/tutorial-8.md:353
msgid "::: ::::::::"
msgstr ""

#: docs/tutorial/tutorial-8.md:356
msgid ""
"You should see you app running, and remaining responsive when you press the "
"button and network content is retrieved."
msgstr ""

#: docs/tutorial/tutorial-8.md:359
msgid "Next steps"
msgstr ""

#: docs/tutorial/tutorial-8.md:361
msgid ""
"This has been a taste for what you can do with the tools provided by the "
"BeeWare project. Over the course of this tutorial, you have:"
msgstr ""

#: docs/tutorial/tutorial-8.md:364
msgid "Created a new GUI app project;"
msgstr ""

#: docs/tutorial/tutorial-8.md:365
msgid "Run that app in development mode;"
msgstr ""

#: docs/tutorial/tutorial-8.md:366
msgid "Built the app as a standalone binary for a desktop operating system;"
msgstr ""

#: docs/tutorial/tutorial-8.md:367
msgid "Packaged that project for distribution to others;"
msgstr ""

#: docs/tutorial/tutorial-8.md:368
msgid "Run the app on a mobile simulator and/or device;"
msgstr ""

#: docs/tutorial/tutorial-8.md:369
msgid "Run the app as a web app;"
msgstr ""

#: docs/tutorial/tutorial-8.md:370
msgid "Added a third-party dependency to your app; and"
msgstr ""

#: docs/tutorial/tutorial-8.md:371
msgid "Modified the app so that it remains responsive."
msgstr ""

#: docs/tutorial/tutorial-8.md:373
msgid "So - where to from here?"
msgstr ""

#: docs/tutorial/tutorial-8.md:375
msgid ""
"If you\\'d like to go further, there are some additional `topic tutorials </"
"tutorial/topics/index>`{.interpreted-text role=\"doc\"} that go into detail "
"on specific aspects of application development."
msgstr ""

#: docs/tutorial/tutorial-8.md:379
msgid ""
"If you\\'d like to know more about how to build complex user interfaces with "
"Toga, you can dive into [Toga\\'s documentation]{1}. Toga also has it\\'s "
"own tutorial "
"[demonstrating how to use various features of the widget toolkit]{2}."
msgstr ""

#: docs/tutorial/tutorial-8.md:384
msgid ""
"If you\\'d like to know more about the capabilities of Briefcase, you can "
"dive into [Briefcase\\'s documentation]{1}."
msgstr ""
